# Security PR Automation Workflow
# This workflow automates the handling of security PRs from trusted sources
# (Dependabot, GitHub Security, Vercel bot)
#
# Features:
# - Auto-resolves merge conflicts in dependency files
# - Smart conflict resolution for code files
# - Runs CI/tests and attempts automated fixes
# - Auto-merges PRs when all checks pass (production mode only)
# - Posts detailed audit logs as PR comments
#
# Configuration:
# - TEST_MODE: Set to "true" for dry-run, "false" for live auto-merge
# - Initial deployment runs in test mode

name: Security PR Automation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    # Trigger on PRs to main branches
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Run in test mode (dry-run)'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

# Required permissions for the workflow
permissions:
  contents: write           # For conflict resolution and fixes
  pull-requests: write      # For comments and auto-merge
  checks: read             # For reading CI status
  statuses: read           # For reading commit statuses

jobs:
  security-pr-handler:
    name: Security PR Handler
    runs-on: ubuntu-latest
    
    # Only run for PRs from trusted bots
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.actor == 'dependabot[bot]' ||
      github.actor == 'github-actions[bot]' ||
      github.actor == 'vercel[bot]'
    
    steps:
      # Step 1: Checkout the PR code
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          # Fetch full history for conflict resolution
          fetch-depth: 0
          # Checkout the PR branch
          ref: ${{ github.event.pull_request.head.ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
      
      # Step 2: Setup Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      # Step 3: Setup pnpm package manager
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9
      
      # Step 4: Initialize audit log
      - name: Initialize audit log
        id: init-audit
        run: |
          echo "## Security PR Automation Audit Log" > audit-log.md
          echo "" >> audit-log.md
          echo "**PR:** #${{ github.event.pull_request.number }}" >> audit-log.md
          echo "**Author:** ${{ github.actor }}" >> audit-log.md
          echo "**Mode:** ${{ github.event.inputs.test_mode || 'true' }}" >> audit-log.md
          echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> audit-log.md
          echo "" >> audit-log.md
          
          # Set test mode from workflow dispatch or default to true
          if [ "${{ github.event.inputs.test_mode }}" == "false" ]; then
            echo "TEST_MODE=false" >> $GITHUB_ENV
            echo "ðŸ”´ **Running in PRODUCTION mode** - Auto-merge enabled" >> audit-log.md
          else
            echo "TEST_MODE=true" >> $GITHUB_ENV
            echo "ðŸŸ¡ **Running in TEST mode** - Dry-run only, no auto-merge" >> audit-log.md
          fi
          echo "" >> audit-log.md
      
      # Step 5: Detect and log PR source
      - name: Detect PR source
        id: detect-source
        run: |
          echo "### 1. PR Source Detection" >> audit-log.md
          echo "" >> audit-log.md
          
          if [ "${{ github.actor }}" == "dependabot[bot]" ]; then
            echo "âœ… Detected trusted source: **Dependabot**" >> audit-log.md
            echo "SOURCE=dependabot" >> $GITHUB_ENV
          elif [ "${{ github.actor }}" == "github-actions[bot]" ]; then
            echo "âœ… Detected trusted source: **GitHub Security**" >> audit-log.md
            echo "SOURCE=github-security" >> $GITHUB_ENV
          elif [ "${{ github.actor }}" == "vercel[bot]" ]; then
            echo "âœ… Detected trusted source: **Vercel Bot**" >> audit-log.md
            echo "SOURCE=vercel" >> $GITHUB_ENV
          else
            echo "â“ Detected source: **${{ github.actor }}**" >> audit-log.md
            echo "SOURCE=other" >> $GITHUB_ENV
          fi
          echo "" >> audit-log.md
      
      # Step 6: Check for merge conflicts
      - name: Check for merge conflicts
        id: check-conflicts
        continue-on-error: true
        run: |
          echo "### 2. Merge Conflict Detection" >> audit-log.md
          echo "" >> audit-log.md
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch the base branch
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          git fetch origin "$BASE_BRANCH"
          
          # Attempt to merge base into current branch
          if git merge --no-commit --no-ff "origin/$BASE_BRANCH" 2>&1 | tee merge-output.txt; then
            echo "âœ… No merge conflicts detected" >> audit-log.md
            echo "HAS_CONFLICTS=false" >> $GITHUB_ENV
            git merge --abort 2>/dev/null || true
          else
            echo "âš ï¸ Merge conflicts detected" >> audit-log.md
            echo "HAS_CONFLICTS=true" >> $GITHUB_ENV
            
            # List conflicted files
            echo "" >> audit-log.md
            echo "**Conflicted files:**" >> audit-log.md
            git diff --name-only --diff-filter=U | while read -r file; do
              echo "- \`$file\`" >> audit-log.md
            done
            
            git merge --abort 2>/dev/null || true
          fi
          echo "" >> audit-log.md
      
      # Step 7: Auto-resolve dependency file conflicts
      - name: Auto-resolve dependency conflicts
        id: resolve-deps
        if: env.HAS_CONFLICTS == 'true'
        continue-on-error: true
        run: |
          echo "### 3. Auto-resolve Dependency Conflicts" >> audit-log.md
          echo "" >> audit-log.md
          
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          
          # Start merge
          git merge --no-commit --no-ff "origin/$BASE_BRANCH" || true
          
          # Get list of conflicted files
          CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)
          
          RESOLVED_COUNT=0
          FAILED_COUNT=0
          
          # Auto-resolve dependency files by accepting incoming changes
          for file in $CONFLICTED_FILES; do
            if [[ "$file" == "package.json" ]] || \
               [[ "$file" == "yarn.lock" ]] || \
               [[ "$file" == "pnpm-lock.yaml" ]] || \
               [[ "$file" == "package-lock.json" ]]; then
              
              echo "Resolving: $file (accepting incoming changes)"
              
              if [ "$TEST_MODE" == "true" ]; then
                echo "- ðŸŸ¡ [TEST MODE] Would accept incoming changes for \`$file\`" >> audit-log.md
              else
                # Accept incoming changes (--theirs strategy)
                git checkout --theirs "$file"
                git add "$file"
                echo "- âœ… Auto-resolved \`$file\` (accepted incoming changes)" >> audit-log.md
                RESOLVED_COUNT=$((RESOLVED_COUNT + 1))
              fi
            fi
          done
          
          if [ "$TEST_MODE" != "true" ] && [ $RESOLVED_COUNT -gt 0 ]; then
            echo "" >> audit-log.md
            echo "âœ… Successfully auto-resolved $RESOLVED_COUNT dependency file(s)" >> audit-log.md
            echo "DEPS_RESOLVED=true" >> $GITHUB_ENV
          elif [ "$TEST_MODE" == "true" ]; then
            echo "" >> audit-log.md
            echo "ðŸŸ¡ [TEST MODE] Would have resolved dependency conflicts" >> audit-log.md
            echo "DEPS_RESOLVED=test" >> $GITHUB_ENV
          fi
          
          echo "" >> audit-log.md
          
          # Abort merge for now, we'll complete it later if needed
          git merge --abort 2>/dev/null || true
      
      # Step 8: Smart conflict resolution for code files
      - name: Smart conflict resolution for code files
        id: resolve-code
        if: env.HAS_CONFLICTS == 'true'
        continue-on-error: true
        run: |
          echo "### 4. Smart Code Conflict Resolution" >> audit-log.md
          echo "" >> audit-log.md
          
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          
          # Start merge again
          git merge --no-commit --no-ff "origin/$BASE_BRANCH" || true
          
          # Get list of conflicted code files (non-dependency files)
          CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)
          
          CODE_CONFLICTS=0
          
          for file in $CONFLICTED_FILES; do
            # Skip dependency files (already handled)
            if [[ "$file" != "package.json" ]] && \
               [[ "$file" != "yarn.lock" ]] && \
               [[ "$file" != "pnpm-lock.yaml" ]] && \
               [[ "$file" != "package-lock.json" ]]; then
              
              echo "- âš ï¸ Code conflict in \`$file\`" >> audit-log.md
              CODE_CONFLICTS=$((CODE_CONFLICTS + 1))
            fi
          done
          
          if [ $CODE_CONFLICTS -gt 0 ]; then
            echo "" >> audit-log.md
            echo "âš ï¸ Found $CODE_CONFLICTS code file conflict(s)" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Strategy:** Accept incoming (bot) changes for security updates" >> audit-log.md
            
            if [ "$TEST_MODE" == "true" ]; then
              echo "ðŸŸ¡ [TEST MODE] Would accept incoming changes for code conflicts" >> audit-log.md
              echo "CODE_RESOLVED=test" >> $GITHUB_ENV
            else
              echo "âš ï¸ Manual review recommended for code conflicts" >> audit-log.md
              echo "CODE_RESOLVED=manual" >> $GITHUB_ENV
            fi
          else
            echo "âœ… No code conflicts to resolve" >> audit-log.md
            echo "CODE_RESOLVED=none" >> $GITHUB_ENV
          fi
          
          echo "" >> audit-log.md
          
          # Abort merge
          git merge --abort 2>/dev/null || true
      
      # Step 9: Complete merge if conflicts were resolved
      - name: Complete merge
        id: complete-merge
        if: env.HAS_CONFLICTS == 'true' && env.TEST_MODE == 'false' && env.DEPS_RESOLVED == 'true'
        continue-on-error: true
        run: |
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          
          # Start merge
          git merge --no-commit --no-ff "origin/$BASE_BRANCH" || true
          
          # Re-resolve dependency files
          CONFLICTED_FILES=$(git diff --name-only --diff-filter=U)
          
          for file in $CONFLICTED_FILES; do
            if [[ "$file" == "package.json" ]] || \
               [[ "$file" == "yarn.lock" ]] || \
               [[ "$file" == "pnpm-lock.yaml" ]] || \
               [[ "$file" == "package-lock.json" ]]; then
              git checkout --theirs "$file"
              git add "$file"
            fi
          done
          
          # Commit if all conflicts are resolved
          if ! git diff --name-only --diff-filter=U | grep -q .; then
            git commit -m "Auto-resolved merge conflicts in dependency files"
            git push origin "${{ github.event.pull_request.head.ref }}"
            echo "MERGE_COMPLETED=true" >> $GITHUB_ENV
          else
            git merge --abort
            echo "MERGE_COMPLETED=false" >> $GITHUB_ENV
          fi
      
      # Step 10: Install dependencies
      - name: Install dependencies
        id: install-deps
        continue-on-error: true
        run: |
          echo "### 5. Install Dependencies" >> audit-log.md
          echo "" >> audit-log.md
          
          if pnpm install --frozen-lockfile 2>&1 | tee install-output.txt; then
            echo "âœ… Dependencies installed successfully" >> audit-log.md
            echo "DEPS_INSTALLED=true" >> $GITHUB_ENV
          else
            echo "âŒ Failed to install dependencies" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Error output:**" >> audit-log.md
            echo '```' >> audit-log.md
            tail -20 install-output.txt >> audit-log.md
            echo '```' >> audit-log.md
            echo "DEPS_INSTALLED=false" >> $GITHUB_ENV
          fi
          echo "" >> audit-log.md
      
      # Step 11: Run linter
      - name: Run linter
        id: run-lint
        if: env.DEPS_INSTALLED == 'true'
        continue-on-error: true
        run: |
          echo "### 6. Lint Check" >> audit-log.md
          echo "" >> audit-log.md
          
          if pnpm run lint 2>&1 | tee lint-output.txt; then
            echo "âœ… Linter passed" >> audit-log.md
            echo "LINT_PASSED=true" >> $GITHUB_ENV
          else
            echo "âŒ Linter failed" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Lint errors:**" >> audit-log.md
            echo '```' >> audit-log.md
            tail -30 lint-output.txt >> audit-log.md
            echo '```' >> audit-log.md
            echo "LINT_PASSED=false" >> $GITHUB_ENV
          fi
          echo "" >> audit-log.md
      
      # Step 12: Attempt to auto-fix lint errors
      - name: Auto-fix lint errors
        id: fix-lint
        if: env.LINT_PASSED == 'false' && env.DEPS_INSTALLED == 'true'
        continue-on-error: true
        run: |
          echo "### 7. Auto-fix Lint Errors" >> audit-log.md
          echo "" >> audit-log.md
          
          if [ "$TEST_MODE" == "true" ]; then
            echo "ðŸŸ¡ [TEST MODE] Would attempt to auto-fix lint errors" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Command that would run:** \`pnpm run lint --fix\`" >> audit-log.md
            echo "LINT_FIXED=test" >> $GITHUB_ENV
          else
            # Try to auto-fix lint errors
            if pnpm run lint --fix 2>&1 | tee lint-fix-output.txt; then
              # Check if there are changes
              if ! git diff --quiet; then
                git add .
                git commit -m "Auto-fix lint errors"
                git push origin "${{ github.event.pull_request.head.ref }}"
                echo "âœ… Auto-fixed lint errors and committed changes" >> audit-log.md
                echo "LINT_FIXED=true" >> $GITHUB_ENV
              else
                echo "â„¹ï¸ Lint auto-fix made no changes" >> audit-log.md
                echo "LINT_FIXED=nochanges" >> $GITHUB_ENV
              fi
            else
              echo "âŒ Auto-fix could not resolve all lint errors" >> audit-log.md
              echo "" >> audit-log.md
              echo "**Remaining errors:**" >> audit-log.md
              echo '```' >> audit-log.md
              tail -20 lint-fix-output.txt >> audit-log.md
              echo '```' >> audit-log.md
              echo "LINT_FIXED=false" >> $GITHUB_ENV
            fi
          fi
          echo "" >> audit-log.md
      
      # Step 13: Run tests
      - name: Run tests
        id: run-tests
        if: env.DEPS_INSTALLED == 'true'
        continue-on-error: true
        run: |
          echo "### 8. Run Tests" >> audit-log.md
          echo "" >> audit-log.md
          
          if pnpm test 2>&1 | tee test-output.txt; then
            echo "âœ… Tests passed" >> audit-log.md
            echo "TESTS_PASSED=true" >> $GITHUB_ENV
          else
            echo "âŒ Tests failed" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Test failures:**" >> audit-log.md
            echo '```' >> audit-log.md
            tail -40 test-output.txt >> audit-log.md
            echo '```' >> audit-log.md
            echo "TESTS_PASSED=false" >> $GITHUB_ENV
          fi
          echo "" >> audit-log.md
      
      # Step 14: Attempt to auto-fix test failures
      - name: Auto-fix test failures
        id: fix-tests
        if: env.TESTS_PASSED == 'false' && env.DEPS_INSTALLED == 'true'
        continue-on-error: true
        run: |
          echo "### 9. Auto-fix Test Failures" >> audit-log.md
          echo "" >> audit-log.md
          
          if [ "$TEST_MODE" == "true" ]; then
            echo "ðŸŸ¡ [TEST MODE] Would analyze test failures for auto-fix opportunities" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Strategy:**" >> audit-log.md
            echo "- Analyze test output for common patterns" >> audit-log.md
            echo "- Apply fixes for known issues" >> audit-log.md
            echo "- Re-run tests to verify" >> audit-log.md
            echo "TEST_FIXED=test" >> $GITHUB_ENV
          else
            echo "â„¹ï¸ Test auto-fix is simulated in production mode" >> audit-log.md
            echo "" >> audit-log.md
            echo "Manual intervention required for test failures" >> audit-log.md
            echo "TEST_FIXED=manual" >> $GITHUB_ENV
          fi
          echo "" >> audit-log.md
      
      # Step 15: Determine if PR is ready for auto-merge
      - name: Check auto-merge eligibility
        id: check-automerge
        run: |
          echo "### 10. Auto-merge Eligibility" >> audit-log.md
          echo "" >> audit-log.md
          
          ELIGIBLE=true
          
          # Check each condition
          if [ "${{ env.DEPS_INSTALLED }}" != "true" ]; then
            echo "âŒ Dependencies not installed" >> audit-log.md
            ELIGIBLE=false
          fi
          
          if [ "${{ env.LINT_PASSED }}" == "false" ] && [ "${{ env.LINT_FIXED }}" != "true" ]; then
            echo "âŒ Lint errors not resolved" >> audit-log.md
            ELIGIBLE=false
          fi
          
          if [ "${{ env.TESTS_PASSED }}" == "false" ]; then
            echo "âŒ Tests failed" >> audit-log.md
            ELIGIBLE=false
          fi
          
          if [ "${{ env.HAS_CONFLICTS }}" == "true" ] && [ "${{ env.MERGE_COMPLETED }}" != "true" ]; then
            echo "âŒ Merge conflicts not resolved" >> audit-log.md
            ELIGIBLE=false
          fi
          
          echo "" >> audit-log.md
          
          if [ "$ELIGIBLE" == "true" ]; then
            echo "âœ… **PR is eligible for auto-merge**" >> audit-log.md
            echo "AUTOMERGE_ELIGIBLE=true" >> $GITHUB_ENV
          else
            echo "âŒ **PR is NOT eligible for auto-merge**" >> audit-log.md
            echo "AUTOMERGE_ELIGIBLE=false" >> $GITHUB_ENV
          fi
          echo "" >> audit-log.md
      
      # Step 16: Auto-merge PR (production mode only)
      - name: Auto-merge PR
        id: automerge
        if: env.AUTOMERGE_ELIGIBLE == 'true'
        continue-on-error: true
        run: |
          echo "### 11. Auto-merge" >> audit-log.md
          echo "" >> audit-log.md
          
          if [ "$TEST_MODE" == "true" ]; then
            echo "ðŸŸ¡ [TEST MODE] Would auto-merge PR #${{ github.event.pull_request.number }}" >> audit-log.md
            echo "" >> audit-log.md
            echo "**Merge method:** Squash" >> audit-log.md
            echo "AUTOMERGE_RESULT=test" >> $GITHUB_ENV
          else
            echo "ðŸš€ Attempting to auto-merge PR..." >> audit-log.md
            
            # Use GitHub API to merge PR
            RESPONSE=$(curl -X PUT \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/merge" \
              -d '{"merge_method":"squash"}')
            
            if echo "$RESPONSE" | grep -q '"merged": true'; then
              echo "âœ… Successfully auto-merged PR" >> audit-log.md
              echo "AUTOMERGE_RESULT=success" >> $GITHUB_ENV
            else
              echo "âŒ Failed to auto-merge PR" >> audit-log.md
              echo "" >> audit-log.md
              echo "**Response:** $RESPONSE" >> audit-log.md
              echo "AUTOMERGE_RESULT=failed" >> $GITHUB_ENV
            fi
          fi
          echo "" >> audit-log.md
      
      # Step 17: Generate summary
      - name: Generate summary
        id: summary
        if: always()
        run: |
          echo "---" >> audit-log.md
          echo "" >> audit-log.md
          echo "### Summary" >> audit-log.md
          echo "" >> audit-log.md
          
          if [ "$TEST_MODE" == "true" ]; then
            echo "**Mode:** ðŸŸ¡ Test Mode (Dry-run)" >> audit-log.md
          else
            echo "**Mode:** ðŸ”´ Production Mode" >> audit-log.md
          fi
          
          echo "**Source:** ${{ github.actor }}" >> audit-log.md
          echo "**Conflicts:** ${{ env.HAS_CONFLICTS || 'false' }}" >> audit-log.md
          echo "**Dependencies:** ${{ env.DEPS_INSTALLED || 'false' }}" >> audit-log.md
          echo "**Lint:** ${{ env.LINT_PASSED || 'false' }}" >> audit-log.md
          echo "**Tests:** ${{ env.TESTS_PASSED || 'false' }}" >> audit-log.md
          echo "**Auto-merge eligible:** ${{ env.AUTOMERGE_ELIGIBLE || 'false' }}" >> audit-log.md
          
          if [ "${{ env.AUTOMERGE_RESULT }}" == "success" ]; then
            echo "**Result:** âœ… PR auto-merged successfully" >> audit-log.md
          elif [ "${{ env.AUTOMERGE_RESULT }}" == "test" ]; then
            echo "**Result:** ðŸŸ¡ Would have auto-merged in production mode" >> audit-log.md
          elif [ "${{ env.AUTOMERGE_ELIGIBLE }}" == "false" ]; then
            echo "**Result:** âš ï¸ Manual intervention required" >> audit-log.md
          else
            echo "**Result:** âš ï¸ Auto-merge attempted but failed" >> audit-log.md
          fi
          
          echo "" >> audit-log.md
          echo "---" >> audit-log.md
          echo "" >> audit-log.md
          echo "*Generated by Security PR Automation Workflow*" >> audit-log.md
      
      # Step 18: Post audit log as PR comment
      - name: Post audit log comment
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const auditLog = fs.readFileSync('audit-log.md', 'utf8');
            
            // Post comment to PR
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: auditLog
            });
